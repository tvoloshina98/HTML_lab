<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<TITLE>Теория к лаб. работе N 2.15</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1251">
<link REL="stylesheet" TYPE="text/css" HREF="mstyle.css">
</HEAD>
<BODY>
     <h2>Регулярные выражения</h2>
<ul>
<li><a href="#ref1">Общее описание</a>;</li>
<li><a href="#ref2">Синтаксис регулярных выражений</a>;</li>
<li><a href="#ref3">Опции поиска</a>;</li>
<li><a href="#ref4">Запоминание найденных подстрок</a>;</li>
</ul>
      <h3><a name="ref1">Общее описание</a></h3>

      <p><em>Регулярные выражения</em> представляют собой образцы для поиска заданных комбинаций символов
        в текстовых строках (такой поиск называется <em>сопоставлением с образцом</em>). Существует
        два способа присваивания переменным регулярных выражений, а именно:</p>

      <ol>
        <li>Использование инициализатора объекта: 
<table><tr><td bgcolor=aqua><pre>
<tt>var re = <strong>/</strong>pattern<strong>/</strong>switch?</tt></pre></td></tr></table>
		</li>
        <li>Использование конструктора <strong>RegExp</strong>: 
<table><tr><td bgcolor=aqua><pre>
<tt>var re = new RegExp(&quot;pattern&quot;[,&quot;switch&quot;]?)</tt></pre></td></tr></table>
		</li>
      </ol>

      <p>Здесь <tt>pattern</tt>&nbsp;&#151; <a href="#ref2">регулярное выражение</a>, а <tt>switch</tt>&nbsp;&#151;
        необязательные <a href="#ref3">опции поиска</a>.</p>

      <p>Инициализаторы объекта, например, <code>var re = /ab+c/</code>, следует применять в тех случаях,
        когда значение регулярного выражения остается неизменным во время работы сценария. Такие регулярные
        выражения компилируются в процессе загрузки сценария и, следовательно, выполняются быстрее.</p>

      <p>Вызов конструктора, например, <code>var re = new RegExp(&quot;ab+c&quot;)</code>, следует применять
        в тех случаях, когда значение переменной будет меняться. Если вы собираетесь использовать регулярное
        выражение несколько раз, то имеет смысл скомпилировать его методом <strong>compile</strong>
        для более эффективного поиска образцов.</p>

      <p>При создании регулярного выражения следует учитывать, что заключение его в кавычки влечет за
        собой необходимость использовать escape-последовательности, как и в любой другой строковой константе.
        Например, следующие два выражения эквивалентны:</p>

<table><tr><td bgcolor=aqua><pre>
var re = /\w+/g;
var re = new&nbsp;RegExp(&quot;\\w+&quot;, &quot;g&quot;); // В строке '\' должно заменяться на '\\'</pre></td></tr></table>
      </div>

      <p class="note"><strong>Примечание</strong>. Регулярное выражение не может быть пустым: два символа
        <tt>//</tt> подряд задают начало комментария. Поэтому для задания пустого регулярного выражения
        используйте выражение<tt> /.?/</tt>.</p>

      <p>Регулярные выражения используются методами <strong>exec</strong>
        и <strong>test</strong> объекта <strong>RegExp</strong>
        и методами <strong>match</strong>, <strong>replace</strong>,
        <strong>search</strong> и <strong>split</strong>
        объекта <strong>String</strong>. Если нам нужно просто проверить,
        содержит ли данная строка подстроку, соответствующую образцу, то используются методы <strong>test</strong>
        или <strong>search</strong>. Если же нам необходимо извлечь подстроку
        (или подстроки), соответствующие образцу, то нам придется воспользоваться методами <strong>exec</strong>
        или <strong>match</strong>. Метод <strong>replace</strong>
        обеспечивает поиск заданной подстроки и замены ее на другую строку, а метод <strong>split</strong>
        позволяет разбить строку на несколько подстрок, основываясь на регулярном выражении или обычной
        текстовой строке. Более подробные сведения о применении регулярных выражений приведены в описании
        соответствующих методов.</p>

      <h3><a name="ref2">Синтаксис регулярных выражений</a></h3>

      <p>Регулярное выражение может состоять из обычных символов; в этом случае оно будет соответствовать
        заданной комбинации символов в строке. Например, выражение <tt>/ком/</tt> соответствует выделенным
        подстрокам в следующих строках: &quot;<strong>ком</strong>ок&quot;, &quot;ла<strong>ком</strong>ка&quot;,
        &quot;глав<strong>ком</strong> флота&quot;. Однако, гибкость и мощь регулярным выражениям придает
        возможность использования в них <em>специальных символов</em> (<strong>метасимволов</strong>), которые перечислены в следующей
        таблице.</p>

      <table border="1" cellspacing="0" cellpadding="5" width="100%">
        <caption>Специальные символы в регулярных выражениях</caption>
        <tr>
          <th><strong>Символ&nbsp;</strong></th>
          <th><strong>Описание</strong></th>
        </tr>
        <tr>
          <td><strong>\</strong></td>
          <td>Для символов, которые обычно трактуются буквально, означает, что следующий символ является
            специальным. Например, /n/ соответствует букве n, а /\n/ соответствует символу перевода
            строки.<br>
            Для символов, которые обычно трактуются как специальные, означает, что символ должен пониматься
            буквально. Например, /^/ означает начало строки, а /\^/ соответствует просто символу ^.
            /\\/ соответствует обратной косой черте \.</td>
        </tr>
        <tr>
          <td><strong>^</strong></td>
          <td>Соответствует началу строки.</td>
        </tr>
        <tr>
          <td><strong>$</strong></td>
          <td>Соответствует концу строки.</td>
        </tr>
        <tr>
          <td><strong>*</strong></td>
          <td>Соответствует повторению предыдущего символа нуль или более раз.</td>
        </tr>
        <tr>
          <td><strong>+</strong></td>
          <td>Соответствует повторению предыдущего символа один или более раз.</td>
        </tr>
        <tr>
          <td><strong>?</strong></td>
          <td>Соответствует повторению предыдущего символа нуль или один раз.</td>
        </tr>
        <tr>
          <td><strong>.</strong></td>
          <td>Соответствует любому символу, кроме символа новой строки.</td>
        </tr>
        <tr>
          <td><strong>(</strong><em>pattern</em><strong>)</strong></td>
          <td>Соответствует строке <em>pattern</em> и <a href="#ref4">запоминает найденное соответствие</a>.</td>
        </tr>
        <tr>
          <td><strong>(?:</strong><em>pattern</em><strong>)</strong></td>
          <td>Соответствует строке <em>pattern</em>, но не запоминает найденное соответствие. Используется
            для группировки частей образца, например, /ко(?:т|шка)/&nbsp;&#151; это краткая запись выражения
            /кот|кошка/.</td>
        </tr>
        <tr>
          <td><strong>(?=</strong><em>pattern</em><strong>)</strong></td>
          <td>Соответствие с &quot;заглядыванием вперед&quot;, происходит при соответствии строки <em>pattern</em>
            без запоминания найденного соответствия. Например, /Windows (?=95|98|NT|2000)/ соответствует
            &quot;Windows &quot; в строке &quot;Windows 98&quot;, но не соответствует в строке &quot;Windows
            3.1&quot;. После сопоставления поиск продолжается с позиции, следующей за найденным соответствием,
            без учета заглядывания вперед.</td>
        </tr>
        <tr>
          <td><strong>(?!</strong><em>pattern</em><strong>)</strong></td>
          <td>Соответствие с &quot;заглядыванием вперед&quot;, происходит при несоответствии строки
            <em>pattern</em> без запоминания найденного соответствия. Например, /Windows (?!95|98|NT|2000)/
            соответствует &quot;Windows &quot; в строке &quot;Windows 3.1&quot;, но не соответствует
            в строке &quot;Windows 98&quot;. После сопоставления поиск продолжается с позиции, следующей
            за найденным соответствием, без учета заглядывания вперед.</td>
        </tr>
        <tr>
          <td><em>x</em><strong>|</strong><em>y</em></td>
          <td>Соответствует <em>x</em> или <em>y</em>.</td>
        </tr>
        <tr>
          <td><strong>{</strong><em>n</em><strong>}</strong></td>
          <td><em>n</em>&nbsp;&#151; неотрицательное число. Соответствует ровно <em>n</em> вхождениям
            предыдущего символа.</td>
        </tr>
        <tr>
          <td><strong>{</strong><em>n</em><strong>,}</strong></td>
          <td><em>n</em>&nbsp;&#151; неотрицательное число. Соответствует <em>n</em> или более вхождениям
            предыдущего символа. /x{1,}/ эквивалентно /x+/. /x{0,}/ эквивалентно /x*/.</td>
        </tr>
        <tr>
          <td><strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}</strong></td>
          <td><em>n</em> и <em>m</em>&nbsp;&#151; неотрицательное числа. Соответствует не менее чем
            <em>n</em> и не более чем <em>m</em> вхождениям предыдущего символа. /x{0,1}/ эквивалентно
            /x?/.</td>
        </tr>
        <tr>
          <td><strong>[</strong><em>xyz</em><strong>]</strong></td>
          <td>Соответствует любому символу из заключенных в квадратные скобки.</td>
        </tr>
        <tr>
          <td><strong>[^</strong><em>xyz</em><strong>]</strong></td>
          <td>Соответствует любому символу, кроме заключенных в квадратные скобки.</td>
        </tr>
        <tr>
          <td><strong>[</strong><em>a</em><strong>-</strong><em>z</em><strong>]</strong></td>
          <td>Соответствует любому символу в указанном диапазоне.</td>
        </tr>
        <tr>
          <td><strong>[^</strong><em>a</em><strong>-</strong><em>z</em><strong>]</strong></td>
          <td>Соответствует любому символу, кроме лежащих в указанном диапазоне.</td>
        </tr>
        <tr>
          <td><strong>\b</strong></td>
          <td>Соответствует границе слова, т.&nbsp;е. позиции между словом и пробелом или переводом
            строки.</td>
        </tr>
        <tr>
          <td><strong>\B</strong></td>
          <td>Соответствует любой позиции, кроме границе слова.</td>
        </tr>
        <tr>
          <td><strong>\с</strong><em>X</em></td>
          <td>Соответствует символу Ctrl+<em>X</em>. Например, /\cI/ эквивалентно /\t/.</td>
        </tr>
        <tr>
          <td><strong>\d</strong></td>
          <td>Соответствует цифре. Эквивалентно [0-9].</td>
        </tr>
        <tr>
          <td><strong>\D</strong></td>
          <td>Соответствует нецифровому символу. Эквивалентно [^0-9].</td>
        </tr>
        <tr>
          <td><strong>\f</strong></td>
          <td>Соответствует символу перевода формата (FF).</td>
        </tr>
        <tr>
          <td><strong>\n</strong></td>
          <td>Соответствует символу перевода строки (LF).</td>
        </tr>
        <tr>
          <td><strong>\r</strong></td>
          <td>Соответствует символу возврата каретки (CR).</td>
        </tr>
        <tr>
          <td><strong>\s</strong></td>
          <td>Соответствует <a href="js02.htm#space-char">символу пробела</a>. Эквивалентно /[&nbsp;\f\n\r\t\v]/.</td>
        </tr>
        <tr>
          <td><strong>\S</strong></td>
          <td>Соответствует любому непробельному символу. Эквивалентно /[^&nbsp;\f\n\r\t\v]/.</td>
        </tr>
        <tr>
          <td><strong>\t</strong></td>
          <td>Соответствует символу табуляции (HT).</td>
        </tr>
        <tr>
          <td><strong>\v</strong></td>
          <td>Соответствует символу вертикальной табуляции (VT).</td>
        </tr>
        <tr>
          <td><strong>\w</strong></td>
          <td>Соответствует латинской букве, цифре или подчеркиванию. Эквивалентно /[A-Za-z0-9_] /.</td>
        </tr>
        <tr>
          <td><strong>\W</strong></td>
          <td>Соответствует любому символу, кроме латинской буквы, цифры или подчеркивания. Эквивалентно
            /[^A-Za-z0-9_] /.</td>
        </tr>
        <tr>
          <td><strong>\</strong><em>n</em></td>
          <td><em>n</em>&nbsp;&#151; положительное число. Соответствует <em>n</em>-ной запомненной подстроке.
            Вычисляется путем подсчета левых круглых скобок. Если левых скобок до этого символа меньше,
            чем <em>n</em>, то эквивалентно \0<em>n</em>.</td>
        </tr>
        <tr>
          <td><strong>\0</strong><em>n</em></td>
          <td><em>n</em>&nbsp;&#151; восьмеричное число, не большее 377. Соответствует символу с восьмеричным
            кодом <em>n</em>. Например, /\011/ эквивалентно /\t/.</td>
        </tr>
        <tr>
          <td><strong>\x</strong><em>n</em></td>
          <td><em>n</em>&nbsp;&#151; шестнадцатеричное число, состоящее из двух цифр. Соответствует
            символу с шестнадцатеричным кодом <em>n</em>. Например, /\x31/ эквивалентно /1/.</td>
        </tr>
        <tr>
          <td><strong>\u</strong><em>n</em></td>
          <td><em>n</em>&nbsp;&#151; шестнадцатеричное число, состоящее из четырех цифр. Соответствует
            символу Unicode с шестнадцатеричным кодом <em>n</em>. Например, /\u00A9/ эквивалентно /&copy;/.</td>
        </tr>
      </table>

      <p>Регулярные выражения вычисляются аналогично остальным выражениям JavaScript, т. е. с учетом
        приоритета операций: операции, имеющие больший приоритет, выполняются первыми. Если операции
        имеют равный приоритет, то они выполняются слева направо. В следующей таблице приведен список
        операций регулярных выражений в порядке убывания их приоритетов; операции, расположенные в одной
        строке таблицы, имеют равный приоритет.</p>

        <table border="1" cellpadding="5" cellspacing="0">
          <tr>
            <th>Операция</th>
          </tr>
          <tr>
            <td><tt>\</tt></td>
          </tr>
          <tr>
            <td><tt>() (?:) (?=) (?!) []</tt></td>
          </tr>
          <tr>
            <td><tt>* + ? . {<em>n</em>} {<em>n</em>,} {<em>n</em>,<em>m</em>}</tt></td>
          </tr>
          <tr>
            <td><tt>^ $ \<em>метасимвол</em></tt></td>
          </tr>
          <tr>
            <td><tt>|</tt></td>
          </tr>
        </table>

      <h3><a name="ref3">Опции поиска</a></h3>

      <p>При создании регулярного выражения мы можем указать дополнительных опции поиска:</p>

      <ul>
        <li><tt>i</tt> (ignore case). Не различать строчные и прописные буквы.</li>
        <li><tt>g</tt> (global search). Глобальный поиск всех вхождений образца.</li>
        <li><tt>m</tt> (multiline). Многострочный поиск.</li>
        <li>Любые комбинации этих трех опций, например <tt>ig</tt> или <tt>gim</tt>.</li>
      </ul>

      <p>Приведем несколько примеров. Поскольку регулярные выражения различают строчные и прописные
        буквы, следующий сценарий</p>

<table><tr><td bgcolor=aqua><pre>
var s = &quot;Изучаем язык JavaScript&quot;;
var re = /JAVA/;
var result = re.test(s) ? &quot;'  &quot; : &quot;' не &quot;;
document.write(&quot;Строка '&quot; + s + result + &quot;соответствует образцу &quot; + re);</pre></td></tr></table> 
      </div>

      <p>выведет в окно обозревателя текст:</p>

      <p><samp>Строка 'Изучаем язык JavaScript' не соответствует образцу /JAVA/</samp></p>

      <p>Если мы теперь заменим вторую строку примера на <code>var re = /JAVA/i;</code>, то на экран
        будет выведен текст:</p>

      <p><samp>Строка 'Изучаем язык JavaScript' соответствует образцу /JAVA/i</samp></p>

      <p>Теперь рассмотрим опцию глобального поиска. Она обычно применяется методом <strong>replace</strong>
        при поиске образца и замены найденной подстроки на новую. Дело в том, что по умолчанию этот
        метод производит замену только первой найденной подстроки и возвращает полученный результат.
        Рассмотрим следующий сценарий:</p>

<table><tr><td bgcolor=aqua><pre>
var s = &quot;Мы пишем сценарии на JavaScript, &quot; +
  &quot;но JavaScript - не единственный сценарный язык.&quot;;
var re = /JavaScript/;
document.write(s.replace(re, &quot;VBScript&quot;));</pre></td></tr></table> 
      </div>

      <p>Он выводит в окно обозревателя текст, который явно не соответствует желаемому результату:</p>

      <p><samp>Мы пишем сценарии на VBScript, но JavaScript - не единственный сценарный язык.</samp></p>

      <p>Для того, чтобы все вхождения строки &quot;JavaScript&quot; были заменены на &quot;VBScript&quot;,
        мы должны изменить значение регулярного выражения на <code>var re = /JavaScript/g;</code>. Тогда
        результирующая строка будет иметь вид:</p>

      <p><samp>Мы пишем сценарии на VBScript, но VBScript - не единственный сценарный язык.</samp></p>

      <p>Наконец, опция многострочного поиска позволяет проводить сопоставление с образцом строкового
        выражения, состоящего из нескольких строк текста, соединенных символами разрыва строки. По умолчанию,
        сопоставление с образцом прекращается, если найден символ разрыва строки. Данная опция преодолевает
        указанное ограничение и обеспечивает поиск образца по всей исходной строке. Она также влияет
        на интерпретацию некоторых специальных символов в регулярных выражениях, а именно:</p>

      <ul>
        <li>Обычно символ <tt>^</tt> сопоставляется только с первым элементом строки. Если же опция
          многострочного поиска включена, то он также сопоставляется с любым элементом строки, которому
          предшествует символ разрыва строки.</li>
        <li>Обычно символ <tt>$</tt> сопоставляется только с последним элементом строки. Если же опция
          многострочного поиска включена, то он также сопоставляется с любым элементом строки, который
          является символом разрыва строки.</li>
      </ul>

      <h3><a name="ref4">Запоминание найденных подстрок</a></h3>

      <p>Если часть регулярного выражения заключена в круглые скобки, то соответствующая ей подстрока
        будет запомнена для последующего использования. Для доступа к запомненным подстрокам используются
        свойства <tt>$1</tt>, &#133;, <tt>$9</tt> объекта <strong>RegExp</strong>
        или элементы массива, возвращаемого методами <strong>exec</strong>
        и <strong>match</strong>. В последнем случае количество найденных
        и запомненных подстрок не ограничено.</p>

      <p>Например, следующий сценарий использует метод <strong>replace</strong>
        для перестановки слов в строке. Для замены найденного текста используются свойства <tt>$1</tt>
        и <tt>$2</tt>.</p>

<table><tr><td bgcolor=aqua><pre>
var re = /(\w+)\s(\w+)/;
var str = &quot;Михаил Булгаков&quot;;
document.write(str.replace(re, &quot;$2, $1&quot;))</pre></td></tr></table> 
      </div>

      <p>Этот сценарий выведет в окно обозревателя текст:</p>

      <p><samp>Булгаков, Михаил</samp></p>

</BODY>
</HTML>

